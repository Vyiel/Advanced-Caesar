
dic = {"A":0,"B":1, "C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,
       "K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16, "R":17,"S":18,"T":19,
       "U":20, "V":21,"W":22,"X":23,"Y":24, "Z":25, "a":26,"b":27, "c":28,"d":29,"e":30,
       "f":31,"g":32,"h":33,"i":34,"j":35, "k":36,"l":37,"m":38,"n":39,"o":40,
       "p":41,"q":42, "r":43,"s":44,"t":45,"u":46, "v":47,"w":48,"x":49,"y":50, "z":51}


def n2c(item):
    # print("item is: " + str(item))
    # converted_list = []
    for corresponding_chars, numbers in dic.items():
        if item == numbers:
            # print(corresponding_chars)
            return corresponding_chars


def c2n(text):
    corresponding = []
    for chars in text:
        if chars in dic:
            corresponding.append(dic[chars])
        else:
            corresponding.append(chars)
    return corresponding


def crypt(broken_text, new_key):
    total_iterations = len(broken_text)
    after_crypt = []
    crypt_list = []
    iterator = 1

    for i in range(total_iterations):
        for j in range(iterator - 1, iterator):
            temp_iter = new_key[j]
            iterator += 1
            for k in broken_text[i]:
                if k in dic.values():
                    after_crypt.append((k + int(temp_iter)) % 51)
                else:
                    after_crypt.append(k)
    # print(after_crypt)

    # return after_crypt
    for modded_items in after_crypt:
        if modded_items in dic.values():
            corresponding_chars = n2c(modded_items)
            crypt_list.append(corresponding_chars)
        else:
            crypt_list.append(str(modded_items))

    crypt_in_str = ''.join(map(str, crypt_list))

    return crypt_in_str


def decrypt(broken_cipher_text, new_key):
    total_iterations = len(broken_cipher_text)
    after_decrypt = []
    decrypt_list = []
    iterator = 1

    for i in range(total_iterations):
        for j in range(iterator - 1, iterator):
            temp_iter = new_key[j]
            iterator += 1
            for k in broken_cipher_text[i]:
                if k in dic.values():
                    after_decrypt.append((k - int(temp_iter)) % 51)
                else:
                    after_decrypt.append(k)
    # print(after_crypt)

    # return after_crypt
    for modded_items in after_decrypt:
        if modded_items in dic.values():
            corresponding_chars = n2c(modded_items)
            decrypt_list.append(corresponding_chars)
        else:
            decrypt_list.append(str(modded_items))

    decrypt_in_str = ''.join(map(str, decrypt_list))

    return decrypt_in_str


def key_delimit(key):
    key_len = len(key)
    key_corresp_total = int(0)
    for i in key:
        if i in dic.values():
            key_corresp_total = key_corresp_total + int(i)
        else:
            key_corresp_total += 0

    delimiter = (key_corresp_total % key_len) + 1
    return delimiter


def valid_key_chars(keys):
    valid_keys = []
    for i in keys:
        try:
            valid_keys.append(int(i))
        except ValueError or TypeError:
            continue
    return valid_keys


def key_stretch(valid_keys, broken_text):
    str_keys_list = []
    for i_keys in valid_keys:
        str_keys_list.append(str(i_keys))
    # print(str_keys_list)

    # key_in_str = "".join(str_keys_list)
    # print(key_in_str, type(key_in_str))

    total_iterations = len(broken_text)
    stretched_key = []
    restart = 1
    old_key_len = len(str_keys_list)
    for q in range(total_iterations):
        # print(q)
        if restart == old_key_len:
            restart = 0
        for i in range(restart - 1, restart):
            stretched_key.append(str_keys_list[i])
        restart += 1

    # print(stretched_key)
    return stretched_key


def break_p_text(conv_text, delimiter):
    broken_text_list = []
    j = 0
    for i in range(len(conv_text)):
        values = (conv_text[j: j + delimiter])
        if len(values) != 0:
            broken_text_list.append(values)
        else:
            break
        j += delimiter
    return broken_text_list



# text = input("Enter Text: ")
# conv_text = c2n(text)
# print(conv_text)
# key = input("Enter Key: ")
# conv_key = c2n(key)
# print(conv_key)
# val_keys = valid_key_chars(conv_key)
# print(val_keys, type(val_keys))
# delimiter = (key_delimit(val_keys))
# # print(delimiter)
# broken_text = break_p_text(conv_text, delimiter)
# print(broken_text)
# stk = key_stretch(valid_keys=val_keys, broken_text=broken_text)
# print(stk)
# c = crypt(broken_text, stk)
# print(c)


def do_crypt():
    text = input("Enter Text: ")
    conv_text = c2n(text)
    key = input("Enter Key: ")
    conv_key = c2n(key)
    val_keys = valid_key_chars(conv_key)
    delimiter = (key_delimit(val_keys))
    broken_text = break_p_text(conv_text, delimiter)
    stretched_key = key_stretch(valid_keys=val_keys, broken_text=broken_text)
    cipher_text = crypt(broken_text, stretched_key)
    return cipher_text

def do_decrypt():
    cipher_text = input("Enter Text: ")
    conv_text = c2n(cipher_text)
    key = input("Enter Key: ")
    conv_key = c2n(key)
    val_keys = valid_key_chars(conv_key)
    delimiter = (key_delimit(val_keys))
    broken_Cipher_text = break_p_text(conv_text, delimiter)
    stretched_key = key_stretch(valid_keys=val_keys, broken_text=broken_Cipher_text)
    plain_text = decrypt(broken_Cipher_text, stretched_key)
    return plain_text


print(do_crypt())
print(do_decrypt())