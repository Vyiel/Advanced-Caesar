
dic = {"A":1,"B":2, "C":3,"D":4,"E":5,"F":6,"G":7,"H":8,"I":9,"J":10,
       "K":11,"L":12,"M":13,"N":14,"O":15,"P":16,"Q":17, "R":18,"S":19,"T":20,
       "U":21, "V":22,"W":23,"X":24,"Y":25, "Z":26, "a":27,"b":28, "c":29,"d":30,"e":31,
       "f":32,"g":33,"h":34,"i":35,"j":36, "k":37,"l":38,"m":39,"n":40,"o":41,
       "p":42,"q":43, "r":44,"s":45,"t":46,"u":47, "v":48,"w":49,"x":50,"y":51, "z":52}

def  n2c(item):
    print("item is: " + str(item))
    converted_list = []
    for corresponding_chars, numbers in dic.items():
        if item == numbers:
            converted_list.append(corresponding_chars)
    return converted_list


def c2n(text):
    corresponding = []
    for chars in text:
        if chars in dic:
            corresponding.append(dic[chars])
        else:
            corresponding.append(chars)
    return corresponding


def crypt(broken_text, new_key):
    total_iterations = len(broken_text)
    after_crypt = []
    crypt_list = []
    for i in range(total_iterations):
        for j in new_key[i]:
            # print(j)
            for k in text[i]:
                # print(k)
                if k in dic.values():
                    after_crypt.append((k + int(j)) % 52)
                else:
                    after_crypt.append(k)

    return after_crypt
    # for modded_items in after_crypt:
    #     if modded_items in dic.values():
    #         corresponding_chars = n2c(modded_items)
    #         crypt_list.append(corresponding_chars)
    #     else:
    #         crypt_list.append(modded_items)
    #
    # to_str = ' '.join(map(str, crypt_list))
    #
    # print(to_str)


def key_delimit(key):
    key_len = len(key)
    key_corresp_total = int(0)
    for i in key:
        if i in dic.values():
            key_corresp_total = key_corresp_total + int(i)
        else:
            key_corresp_total += 0

    delimiter = (key_corresp_total % key_len) + 1
    return delimiter


def valid_key_chars(keys):
    valid_keys = []
    for i in keys:
        try:
            valid_keys.append(int(i))
        except ValueError or TypeError:
            continue
    return valid_keys


def key_stretch(valid_keys, broken_text):
    str_keys_list = []
    for i_keys in valid_keys:
        str_keys_list.append(str(i_keys))

    # print(str_keys_list)

    # key_in_str = "".join(str_keys_list)
    # print(key_in_str, type(key_in_str))
    total_iterations = len(broken_text)
    stretched_key = []
    restart = 1
    old_key_len = len(str_keys_list)
    for q in range(total_iterations):
        # print(q)
        if restart == old_key_len:
            restart = 0
        for i in range(restart - 1, restart):
            stretched_key.append(str_keys_list[i])
        restart += 1

    print(stretched_key)
    # return stretched_key


def break_p_text(conv_text, delimiter):
    broken_text_list = []
    j = 0
    for i in range(len(conv_text)):
        values = (conv_text[j: j + delimiter])
        if len(values) != 0:
            broken_text_list.append(values)
        else:
            break
        j += delimiter
    return broken_text_list



text = input("Enter Text: ")
conv_text = c2n(text)
# print(conv_text)
key = input("Enter Key: ")
conv_key = c2n(key)
# print(conv_key)
val_keys = valid_key_chars(conv_key)
print(val_keys, type(val_keys))
delimiter = (key_delimit(val_keys))
# print(delimiter)
broken_text = break_p_text(conv_text, delimiter)
print(broken_text)
stk = key_stretch(valid_keys=val_keys, broken_text=broken_text)
print(stk)
